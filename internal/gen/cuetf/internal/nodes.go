package internal

import (
	"errors"
	"fmt"
	"regexp"
	"strings"

	"cuelang.org/go/cue"
	"cuelang.org/go/cue/ast"
	"github.com/K-Phoen/grabana/internal/gen/cuetf/types"
)

func GetAllNodes(val cue.Value) ([]types.Node, error) {
	if err := val.Validate(); err != nil {
		return nil, fmt.Errorf("error validating value: %w", err)
	}

	iter, err := val.Fields(
		cue.Definitions(false), // Should we do something with those?
		cue.Optional(true),
	)
	if err != nil {
		return nil, fmt.Errorf("error retrieving value fields: %w", err)
	}

	nodes := make([]types.Node, 0)
	for iter.Next() {
		if iter.Selector().String() == "id" {
			// id is a field generated by the Grafana server and should not be included in the schema
			continue
		}

		node, err := GetSingleNode(iter.Selector().String(), iter.Value(), iter.IsOptional())
		if err != nil {
			return nil, err
		}

		if node != nil {
			nodes = append(nodes, *node)
		}
	}

	return nodes, nil
}

func GetSingleNode(name string, val cue.Value, optional bool) (*types.Node, error) {
	// TODO: fixme
	if name == "reducer" {
		return nil, nil
	}

	node := types.Node{
		Name: name,
		Kind: val.IncompleteKind(),
		// Structs should be optional if we want to set nested defaults
		Optional: optional || val.IncompleteKind() == cue.StructKind,
		Default:  getDefault(val),
		Doc:      formatDoc(val.Doc()),
	}

	val = cue.Dereference(val)
	op, args := val.Expr()
	if op == cue.OrOp {
		err := handleDisjunction(&node, args)
		return &node, err
	}

	switch node.Kind {
	case cue.ListKind:
		err := handleList(&node, val)
		if err != nil {
			return nil, err
		}
	case cue.StructKind:
		// Checks [string]something only.
		// It skips structs like {...} (cue.TopKind) to avoid undesired results.
		v := val.LookupPath(cue.MakePath(cue.AnyString))
		if v.Exists() && v.IncompleteKind() != cue.TopKind {
			val = v
			node.IsMap = true
		}

		children, err := GetAllNodes(val.Value())
		if err != nil {
			return nil, err
		}

		node.Children = children
		for i := range node.Children {
			node.Children[i].Parent = &node
		}
	}

	return &node, nil
}

func handleList(node *types.Node, val cue.Value) error {
	node.Optional = true

	// TODO: fixme
	// Using a string type to allow composition of panel datasources
	// Doesn't seem possible to have an arbitrary map type here
	if node.Name == "panels" || node.Name == "targets" {
		node.SubKind = cue.StringKind
		return nil
	}

	// From cuetsy:
	// If the default (all lists have a default, usually self, ugh) differs from the
	// input list, peel it off. Otherwise our AnyIndex lookup may end up getting
	// sent on the wrong path.
	defv, _ := val.Default()
	if !defv.Equals(val) {
		_, v := val.Expr()
		val = v[0]
	}

	e := val.LookupPath(cue.MakePath(cue.AnyIndex))
	if !e.Exists() {
		return errors.New("unreachable - open list must have a type")
	}

	e = cue.Dereference(e)
	op, args := e.Expr()
	if op == cue.OrOp {
		return handleDisjunction(node, args)
	}

	node.SubKind = e.IncompleteKind()
	switch node.SubKind {
	case cue.StructKind:
		children, err := GetAllNodes(e)
		if err != nil {
			return err
		}

		node.Children = children
		for i := range node.Children {
			node.Children[i].Parent = node
		}
	case cue.ListKind:
		// TODO - handle list in list
	case cue.TopKind:
		// TODO - handle open lists ([...])
	}

	return nil
}

func handleDisjunction(node *types.Node, vals []cue.Value) error {
	children := make([]types.Node, 0)
	disjuncts := make([]cue.Value, 0)

	isComplex := false
	for _, val := range vals {
		isStructOrList := val.IncompleteKind() == cue.StructKind || val.IncompleteKind() == cue.ListKind
		if isStructOrList || !containsKind(disjuncts, val.IncompleteKind()) {
			disjuncts = append(disjuncts, val)
		}

		if isStructOrList {
			isComplex = true
		}
	}

	if len(disjuncts) <= 1 && !isComplex {
		return nil
	}

	if !isComplex || containsKind(disjuncts, cue.StringKind) {
		node.Kind = cue.StringKind
		for _, d := range disjuncts {
			node.DisjunctionKinds = append(node.DisjunctionKinds, d.IncompleteKind())
		}
		if isComplex {
			node.Doc = "JSON-encoded string. " + node.Doc
		}
		return nil
	}

	for _, val := range disjuncts {
		node.SubKind = val.IncompleteKind()

		_, p := val.ReferencePath()
		arr := strings.Split(p.String(), ".")
		name := strings.ReplaceAll(arr[len(arr)-1], "#", "")
		// TODO - currently this catches setting a default object
		if name == "" {
			continue
		}

		child, err := GetSingleNode(name, val, true)
		if err != nil {
			return err
		}
		child.Parent = node

		children = append(children, *child)
	}
	node.IsDisjunction = true
	node.Children = children

	return nil
}

func containsKind(values []cue.Value, kind cue.Kind) bool {
	for _, v := range values {
		if v.IncompleteKind() == kind {
			return true
		}
	}
	return false
}

func getDefault(v cue.Value) string {
	_, ok := v.Default()
	if !ok {
		return ""
	}

	switch v.IncompleteKind() {
	case cue.StringKind:
		s, err := v.String()
		if err != nil {
			return ""
		}
		return fmt.Sprintf("`%s`", s)
	case cue.FloatKind, cue.NumberKind:
		f, err := v.Float64()
		if err != nil {
			return ""
		}
		return fmt.Sprintf("%f", f)
	case cue.IntKind:
		i, err := v.Int64()
		if err != nil {
			return ""
		}
		return fmt.Sprintf("%d", i)
	case cue.BoolKind:
		b, err := v.Bool()
		if err != nil {
			return ""
		}
		return fmt.Sprintf("%t", b)
	default:
		return ""
	}
}

func formatDoc(comments []*ast.CommentGroup) string {
	result := ""
	for _, comment := range comments {
		result += comment.Text()
	}

	result = strings.ReplaceAll(result, "`", "")

	reg := regexp.MustCompile(`{{([^}]*)}}`)
	result = reg.ReplaceAllString(result, "` + \"{{`{{${1}}}`}}\" + `")

	return strings.Trim(result, "\n ")
}
